
#include "stm32l152xe.h"
#include "stm32l1xx.h"
#include <stdint.h>

volatile uint32_t* RCCCFGR = &(RCC->CFGR);
/** @brief Configures the clock to use HSE (external oscillator) and the PLL
   to get SysClk == AHB == APB1 == APB2 == 24MHz */
static void
_configClock (void)
{
  
  RCC->CFGR = (uint32_t)0;
  RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN; // Enable SYSCFG clock
  RCC->APB1ENR |= RCC_APB1ENR_PWREN; // Enable PWR config clock
  
  PWR->CR &= ~PWR_CR_VOS_Msk;
  PWR->CR |= PWR_CR_VOS_0; // VOS to 1.8V
  FLASH->ACR |= FLASH_ACR_ACC64;
  FLASH->ACR |= FLASH_ACR_LATENCY_Msk; // Set 1 wait state on NVM
  
  RCC->CR &= ~RCC_CR_PLLON; // Disable PLL
  while (RCC->CR & ((uint32_t)1 << 25)); // Wait till PLL is off
  
  // Set PLL for 32MHz output ((16/2)*4 = 24)
  RCC->CFGR |= (uint32_t)0b01 << 22; // Divide HSI16 by 2
  RCC->CFGR |= (uint32_t)0b0001 << 18; // Multiply by 4

  RCC->CR |= RCC_CR_HSION; // Enable HSI16
  while ((RCC->CR & ((uint32_t)1 << 1)) != ((uint32_t)1 << 1)); // Wait till HSI16 is ready
  
  RCC->CR |= RCC_CR_PLLON; // Enable PLL
  while ((RCC->CR & ((uint32_t)1 << 25)) != ((uint32_t)1 << 25)); // Wait till PLL is stable

  uint32_t val = RCC->CFGR & 0b11;
  RCC->CFGR |= val | (uint32_t)0b11; // Set PLL as system clock
  
  while ((RCC->CFGR & ((uint32_t)0b11 << 2)) != ((uint32_t)0b11 << 2)); //Wait till PLL is set as system clock
  
  RCC->CR &= ~RCC_CR_MSION;
}

static void ioInit (void) {
  GPIOA->MODER |= 0b01 << 8;
  
}

/** @brief Configures the NVIC with the used IRQs.
 */
static void
_configIRQs (void)
{
  
}

void
enable_tick ()
{
  SystemCoreClockUpdate ();
  SysTick_Config (SystemCoreClock / 1000);
  NVIC_EnableIRQ (SysTick_IRQn);
  NVIC_SetPriority (SysTick_IRQn,
                    0); // Set Systick to highest priority
}

void
platform_init ()
{
  SystemInit ();
  // Set Stack Alignment
  SCB->CCR |= SCB_CCR_STKALIGN_Msk;
  _configClock ();
  _configIRQs ();
  enable_tick();
  ioInit();
}

void
software_reset()
{
  NVIC_SystemReset();
}
